{"ast":null,"code":"import React, { useState, useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from '../index/index.mjs';\nimport { IS_REACT_LEGACY, useIsomorphicLayoutEffect, withMiddleware, serialize, mergeObjects, getTimestamp, UNDEFINED } from '../_internal/index.mjs';\nconst startTransition = IS_REACT_LEGACY ? cb => {\n  cb();\n} : React.startTransition;\n/**\n * An implementation of state with dependency-tracking.\n * @param initialState - The initial state object.\n */\nconst useStateWithDeps = initialState => {\n  const [, rerender] = useState({});\n  const unmountedRef = useRef(false);\n  const stateRef = useRef(initialState);\n  // If a state property (data, error, or isValidating) is accessed by the render\n  // function, we mark the property as a dependency so if it is updated again\n  // in the future, we trigger a rerender.\n  // This is also known as dependency-tracking.\n  const stateDependenciesRef = useRef({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  /**\n  * Updates state and triggers re-render if necessary.\n  * @param payload To change stateRef, pass the values explicitly to setState:\n  * @example\n  * ```js\n  * setState({\n  *   isValidating: false\n  *   data: newData // set data to newData\n  *   error: undefined // set error to undefined\n  * })\n  *\n  * setState({\n  *   isValidating: false\n  *   data: undefined // set data to undefined\n  *   error: err // set error to err\n  * })\n  * ```\n  */\n  const setState = useCallback(payload => {\n    let shouldRerender = false;\n    const currentState = stateRef.current;\n    for (const key in payload) {\n      if (Object.prototype.hasOwnProperty.call(payload, key)) {\n        const k = key;\n        // If the property has changed, update the state and mark rerender as\n        // needed.\n        if (currentState[k] !== payload[k]) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          currentState[k] = payload[k];\n          // If the property is accessed by the component, a rerender should be\n          // triggered.\n          if (stateDependenciesRef.current[k]) {\n            shouldRerender = true;\n          }\n        }\n      }\n    }\n    if (shouldRerender && !unmountedRef.current) {\n      rerender({});\n    }\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    unmountedRef.current = false;\n    return () => {\n      unmountedRef.current = true;\n    };\n  });\n  return [stateRef, stateDependenciesRef.current, setState];\n};\nconst mutation = () => function (key, fetcher) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    mutate\n  } = useSWRConfig();\n  const keyRef = useRef(key);\n  const fetcherRef = useRef(fetcher);\n  const configRef = useRef(config);\n  // Ditch all mutation results that happened earlier than this timestamp.\n  const ditchMutationsUntilRef = useRef(0);\n  const [stateRef, stateDependencies, setState] = useStateWithDeps({\n    data: UNDEFINED,\n    error: UNDEFINED,\n    isMutating: false\n  });\n  const currentState = stateRef.current;\n  const trigger = useCallback(async (arg, opts) => {\n    const [serializedKey, resolvedKey] = serialize(keyRef.current);\n    if (!fetcherRef.current) {\n      throw new Error('Can’t trigger the mutation: missing fetcher.');\n    }\n    if (!serializedKey) {\n      throw new Error('Can’t trigger the mutation: missing key.');\n    }\n    // Disable cache population by default.\n    const options = mergeObjects(mergeObjects({\n      populateCache: false,\n      throwOnError: true\n    }, configRef.current), opts);\n    // Trigger a mutation, and also track the timestamp. Any mutation that happened\n    // earlier this timestamp should be ignored.\n    const mutationStartedAt = getTimestamp();\n    ditchMutationsUntilRef.current = mutationStartedAt;\n    setState({\n      isMutating: true\n    });\n    try {\n      const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n        arg\n      }),\n      // We must throw the error here so we can catch and update the states.\n      mergeObjects(options, {\n        throwOnError: true\n      }));\n      // If it's reset after the mutation, we don't broadcast any state change.\n      if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n        startTransition(() => setState({\n          data,\n          isMutating: false,\n          error: undefined\n        }));\n        options.onSuccess == null ? void 0 : options.onSuccess.call(options, data, serializedKey, options);\n      }\n      return data;\n    } catch (error) {\n      // If it's reset after the mutation, we don't broadcast any state change\n      // or throw because it's discarded.\n      if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n        startTransition(() => setState({\n          error: error,\n          isMutating: false\n        }));\n        options.onError == null ? undefined : options.onError.call(options, error, serializedKey, options);\n        if (options.throwOnError) {\n          throw error;\n        }\n      }\n    }\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  const reset = useCallback(() => {\n    ditchMutationsUntilRef.current = getTimestamp();\n    setState({\n      data: UNDEFINED,\n      error: UNDEFINED,\n      isMutating: false\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    keyRef.current = key;\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n  });\n  // We don't return `mutate` here as it can be pretty confusing (e.g. people\n  // calling `mutate` but they actually mean `trigger`).\n  // And also, `mutate` relies on the useSWR hook to exist too.\n  return {\n    trigger,\n    reset,\n    get data() {\n      stateDependencies.data = true;\n      return currentState.data;\n    },\n    get error() {\n      stateDependencies.error = true;\n      return currentState.error;\n    },\n    get isMutating() {\n      stateDependencies.isMutating = true;\n      return currentState.isMutating;\n    }\n  };\n};\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */\nconst useSWRMutation = withMiddleware(useSWR, mutation);\nexport { useSWRMutation as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}