{"ast":null,"code":"'use client';\n\nimport React, { useEffect, useLayoutEffect, createContext, useContext, useMemo, useRef, createElement } from 'react';\nimport * as revalidateEvents from './events.mjs';\nimport { dequal } from 'dequal/lite';\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\n\n// Shared state between server components and client components\nconst noop = () => {};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/noop();\nconst OBJECT = Object;\nconst isUndefined = v => v === UNDEFINED;\nconst isFunction = v => typeof v == 'function';\nconst mergeObjects = (a, b) => ({\n  ...a,\n  ...b\n});\nconst isPromiseLike = x => isFunction(x.then);\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst isLegacyDeno = isWindowDefined && 'Deno' in window;\nconst hasRequestAnimationFrame = () => isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key) => {\n  const state = SWRGlobalState.get(cache);\n  return [\n  // Getter\n  () => !isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n  // Setter\n  info => {\n    if (!isUndefined(key)) {\n      const prev = cache.get(key);\n      // Before writing to the store, we keep the value in the initial cache\n      // if it's not there yet.\n      if (!(key in INITIAL_CACHE)) {\n        INITIAL_CACHE[key] = prev;\n      }\n      state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n    }\n  },\n  // Subscriber\n  state[6],\n  // Get server cache snapshot\n  () => {\n    if (!isUndefined(key)) {\n      // If the cache was updated on the client, we return the stored initial value.\n      if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n    }\n    // If we haven't done any client-side updates, we return the current value.\n    return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n  }];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */\nlet online = true;\nconst isOnline = () => online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [window.addEventListener.bind(window), window.removeEventListener.bind(window)] : [noop, noop];\nconst isVisible = () => {\n  const visibilityState = isDocumentDefined && document.visibilityState;\n  return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = callback => {\n  // focus revalidate\n  if (isDocumentDefined) {\n    document.addEventListener('visibilitychange', callback);\n  }\n  onWindowEvent('focus', callback);\n  return () => {\n    if (isDocumentDefined) {\n      document.removeEventListener('visibilitychange', callback);\n    }\n    offWindowEvent('focus', callback);\n  };\n};\nconst initReconnect = callback => {\n  // revalidate on reconnected\n  const onOnline = () => {\n    online = true;\n    callback();\n  };\n  // nothing to revalidate, just update the status\n  const onOffline = () => {\n    online = false;\n  };\n  onWindowEvent('online', onOnline);\n  onWindowEvent('offline', onOffline);\n  return () => {\n    offWindowEvent('online', onOnline);\n    offWindowEvent('offline', onOffline);\n  };\n};\nconst preset = {\n  isOnline,\n  isVisible\n};\nconst defaultConfigOptions = {\n  initFocus,\n  initReconnect\n};\nconst IS_REACT_LEGACY = !React.useId;\nconst IS_SERVER = !isWindowDefined || isLegacyDeno;\n// Polyfill requestAnimationFrame\nconst rAF = f => hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst getTypeName = value => OBJECT.prototype.toString.call(value);\nconst isObjectTypeName = (typeName, type) => typeName === `[object ${type}]`;\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = arg => {\n  const type = typeof arg;\n  const typeName = getTypeName(arg);\n  const isDate = isObjectTypeName(typeName, 'Date');\n  const isRegex = isObjectTypeName(typeName, 'RegExp');\n  const isPlainObject = isObjectTypeName(typeName, 'Object');\n  let result;\n  let index;\n  if (OBJECT(arg) === arg && !isDate && !isRegex) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result;\n    // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n    result = ++counter + '~';\n    table.set(arg, result);\n    if (Array.isArray(arg)) {\n      // Array.\n      result = '@';\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n      table.set(arg, result);\n    }\n    if (isPlainObject) {\n      // Object, sort keys.\n      result = '#';\n      const keys = OBJECT.keys(arg).sort();\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n  return result;\n};\nconst serialize = key => {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n  // Use the original key as the argument of fetcher. This can be a string or an\n  // array of values.\n  const args = key;\n  // If key is not falsy, or not an empty array, hash it.\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  return [key, args];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = () => ++__timestamp;\nasync function internalMutate() {\n  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  const [cache, _key, _data, _opts] = args;\n  // When passing as a boolean, it's explicitly used to disable/enable\n  // revalidation.\n  const options = mergeObjects({\n    populateCache: true,\n    throwOnError: true\n  }, typeof _opts === 'boolean' ? {\n    revalidate: _opts\n  } : _opts || {});\n  let populateCache = options.populateCache;\n  const rollbackOnErrorOption = options.rollbackOnError;\n  let optimisticData = options.optimisticData;\n  const rollbackOnError = error => {\n    return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n  };\n  const throwOnError = options.throwOnError;\n  // If the second argument is a key filter, return the mutation results for all\n  // filtered keys.\n  if (isFunction(_key)) {\n    const keyFilter = _key;\n    const matchedKeys = [];\n    const it = cache.keys();\n    for (const key of it) {\n      if (\n      // Skip the special useSWRInfinite and useSWRSubscription keys.\n      !/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n        matchedKeys.push(key);\n      }\n    }\n    return Promise.all(matchedKeys.map(mutateByKey));\n  }\n  return mutateByKey(_key);\n  async function mutateByKey(_k) {\n    // Serialize key\n    const [key] = serialize(_k);\n    if (!key) return;\n    const [get, set] = createCacheHelper(cache, key);\n    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n    const startRevalidate = () => {\n      const revalidators = EVENT_REVALIDATORS[key];\n      const revalidate = isFunction(options.revalidate) ? options.revalidate(get().data, _k) : options.revalidate !== false;\n      if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        delete PRELOAD[key];\n        if (revalidators && revalidators[0]) {\n          return revalidators[0](revalidateEvents.MUTATE_EVENT).then(() => get().data);\n        }\n      }\n      return get().data;\n    };\n    // If there is no new data provided, revalidate the key with current state.\n    if (args.length < 3) {\n      // Revalidate and broadcast state.\n      return startRevalidate();\n    }\n    let data = _data;\n    let error;\n    let isError = false;\n    // Update global timestamps.\n    const beforeMutationTs = getTimestamp();\n    MUTATION[key] = [beforeMutationTs, 0];\n    const hasOptimisticData = !isUndefined(optimisticData);\n    const state = get();\n    // `displayedData` is the current value on screen. It could be the optimistic value\n    // that is going to be overridden by a `committedData`, or get reverted back.\n    // `committedData` is the validated value that comes from a fetch or mutation.\n    const displayedData = state.data;\n    const currentData = state._c;\n    const committedData = isUndefined(currentData) ? displayedData : currentData;\n    // Do optimistic data update.\n    if (hasOptimisticData) {\n      optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n      // When we set optimistic data, backup the current committedData data in `_c`.\n      set({\n        data: optimisticData,\n        _c: committedData\n      });\n    }\n    if (isFunction(data)) {\n      // `data` is a function, call it passing current cache value.\n      try {\n        data = data(committedData);\n      } catch (err) {\n        // If it throws an error synchronously, we shouldn't update the cache.\n        error = err;\n        isError = true;\n      }\n    }\n    // `data` is a promise/thenable, resolve the final data first.\n    if (data && isPromiseLike(data)) {\n      // This means that the mutation is async, we need to check timestamps to\n      // avoid race conditions.\n      data = await data.catch(err => {\n        error = err;\n        isError = true;\n      });\n      // Check if other mutations have occurred since we've started this mutation.\n      // If there's a race we don't update cache or broadcast the change,\n      // just return the data.\n      if (beforeMutationTs !== MUTATION[key][0]) {\n        if (isError) throw error;\n        return data;\n      } else if (isError && hasOptimisticData && rollbackOnError(error)) {\n        // Rollback. Always populate the cache in this case but without\n        // transforming the data.\n        populateCache = true;\n        // Reset data to be the latest committed data, and clear the `_c` value.\n        set({\n          data: committedData,\n          _c: UNDEFINED\n        });\n      }\n    }\n    // If we should write back the cache after request.\n    if (populateCache) {\n      if (!isError) {\n        // Transform the result into data.\n        if (isFunction(populateCache)) {\n          const populateCachedData = populateCache(data, committedData);\n          set({\n            data: populateCachedData,\n            error: UNDEFINED,\n            _c: UNDEFINED\n          });\n        } else {\n          // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n          set({\n            data,\n            error: UNDEFINED,\n            _c: UNDEFINED\n          });\n        }\n      }\n    }\n    // Reset the timestamp to mark the mutation has ended.\n    MUTATION[key][1] = getTimestamp();\n    // Update existing SWR Hooks' internal states:\n    Promise.resolve(startRevalidate()).then(() => {\n      // The mutation and revalidation are ended, we can clear it since the data is\n      // not an optimistic value anymore.\n      set({\n        _c: UNDEFINED\n      });\n    });\n    // Throw error or return data\n    if (isError) {\n      if (throwOnError) throw error;\n      return;\n    }\n    return data;\n  }\n}\nconst revalidateAllKeys = (revalidators, type) => {\n  for (const key in revalidators) {\n    if (revalidators[key][0]) revalidators[key][0](type);\n  }\n};\nconst initCache = (provider, options) => {\n  // The global state for a specific provider will be used to deduplicate\n  // requests and store listeners. As well as a mutate function that is bound to\n  // the cache.\n  // The provider's global state might be already initialized. Let's try to get the\n  // global state associated with the provider first.\n  if (!SWRGlobalState.has(provider)) {\n    const opts = mergeObjects(defaultConfigOptions, options);\n    // If there's no global state bound to the provider, create a new one with the\n    // new mutate function.\n    const EVENT_REVALIDATORS = Object.create(null);\n    const mutate = internalMutate.bind(UNDEFINED, provider);\n    let unmount = noop;\n    const subscriptions = Object.create(null);\n    const subscribe = (key, callback) => {\n      const subs = subscriptions[key] || [];\n      subscriptions[key] = subs;\n      subs.push(callback);\n      return () => subs.splice(subs.indexOf(callback), 1);\n    };\n    const setter = (key, value, prev) => {\n      provider.set(key, value);\n      const subs = subscriptions[key];\n      if (subs) {\n        for (const fn of subs) {\n          fn(value, prev);\n        }\n      }\n    };\n    const initProvider = () => {\n      if (!SWRGlobalState.has(provider)) {\n        // Update the state if it's new, or if the provider has been extended.\n        SWRGlobalState.set(provider, [EVENT_REVALIDATORS, Object.create(null), Object.create(null), Object.create(null), mutate, setter, subscribe]);\n        if (!IS_SERVER) {\n          // When listening to the native events for auto revalidations,\n          // we intentionally put a delay (setTimeout) here to make sure they are\n          // fired after immediate JavaScript executions, which can be\n          // React's state updates.\n          // This avoids some unnecessary revalidations such as\n          // https://github.com/vercel/swr/issues/1680.\n          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, revalidateEvents.FOCUS_EVENT)));\n          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, revalidateEvents.RECONNECT_EVENT)));\n          unmount = () => {\n            releaseFocus && releaseFocus();\n            releaseReconnect && releaseReconnect();\n            // When un-mounting, we need to remove the cache provider from the state\n            // storage too because it's a side-effect. Otherwise, when re-mounting we\n            // will not re-register those event listeners.\n            SWRGlobalState.delete(provider);\n          };\n        }\n      }\n    };\n    initProvider();\n    // This is a new provider, we need to initialize it and setup DOM events\n    // listeners for `focus` and `reconnect` actions.\n    // We might want to inject an extra layer on top of `provider` in the future,\n    // such as key serialization, auto GC, etc.\n    // For now, it's just a `Map` interface without any modifications.\n    return [provider, mutate, initProvider, unmount];\n  }\n  return [provider, SWRGlobalState.get(provider)[4]];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts) => {\n  const maxRetryCount = config.errorRetryCount;\n  const currentRetryCount = opts.retryCount;\n  // Exponential backoff\n  const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n    return;\n  }\n  setTimeout(revalidate, timeout, opts);\n};\nconst compare = dequal;\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n  // events\n  onLoadingSlow: noop,\n  onSuccess: noop,\n  onError: noop,\n  onErrorRetry,\n  onDiscarded: noop,\n  // switches\n  revalidateOnFocus: true,\n  revalidateOnReconnect: true,\n  revalidateIfStale: true,\n  shouldRetryOnError: true,\n  // timeouts\n  errorRetryInterval: slowConnection ? 10000 : 5000,\n  focusThrottleInterval: 5 * 1000,\n  dedupingInterval: 2 * 1000,\n  loadingTimeout: slowConnection ? 5000 : 3000,\n  // providers\n  compare,\n  isPaused: () => false,\n  cache,\n  mutate,\n  fallback: {}\n},\n// use web preset by default\npreset);\nconst mergeConfigs = (a, b) => {\n  // Need to create a new object to avoid mutating the original here.\n  const v = mergeObjects(a, b);\n  // If two configs are provided, merge their `use` and `fallback` options.\n  if (b) {\n    const {\n      use: u1,\n      fallback: f1\n    } = a;\n    const {\n      use: u2,\n      fallback: f2\n    } = b;\n    if (u1 && u2) {\n      v.use = u1.concat(u2);\n    }\n    if (f1 && f2) {\n      v.fallback = mergeObjects(f1, f2);\n    }\n  }\n  return v;\n};\nconst SWRConfigContext = createContext({});\nconst SWRConfig = props => {\n  const {\n    value\n  } = props;\n  const parentConfig = useContext(SWRConfigContext);\n  const isFunctionalConfig = isFunction(value);\n  const config = useMemo(() => isFunctionalConfig ? value(parentConfig) : value, [isFunctionalConfig, parentConfig, value]);\n  // Extend parent context values and middleware.\n  const extendedConfig = useMemo(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [isFunctionalConfig, parentConfig, config]);\n  // Should not use the inherited provider.\n  const provider = config && config.provider;\n  // initialize the cache only on first access.\n  const cacheContextRef = useRef(UNDEFINED);\n  if (provider && !cacheContextRef.current) {\n    cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n  }\n  const cacheContext = cacheContextRef.current;\n  // Override the cache if a new provider is given.\n  if (cacheContext) {\n    extendedConfig.cache = cacheContext[0];\n    extendedConfig.mutate = cacheContext[1];\n  }\n  // Unsubscribe events.\n  useIsomorphicLayoutEffect(() => {\n    if (cacheContext) {\n      cacheContext[2] && cacheContext[2]();\n      return cacheContext[3];\n    }\n  }, []);\n  return createElement(SWRConfigContext.Provider, mergeObjects(props, {\n    value: extendedConfig\n  }));\n};\nexport { noop as A, isPromiseLike as B, IS_REACT_LEGACY as I, OBJECT as O, SWRConfigContext as S, UNDEFINED as U, isFunction as a, SWRGlobalState as b, cache as c, defaultConfig as d, isUndefined as e, mergeConfigs as f, SWRConfig as g, initCache as h, isWindowDefined as i, mutate as j, compare as k, stableHash as l, mergeObjects as m, internalMutate as n, getTimestamp as o, preset as p, defaultConfigOptions as q, IS_SERVER as r, serialize as s, rAF as t, useIsomorphicLayoutEffect as u, slowConnection as v, isDocumentDefined as w, isLegacyDeno as x, hasRequestAnimationFrame as y, createCacheHelper as z };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}