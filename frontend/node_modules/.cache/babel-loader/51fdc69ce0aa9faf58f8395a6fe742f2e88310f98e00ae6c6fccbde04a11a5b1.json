{"ast":null,"code":"import { isStaging } from \"./chunk-3TMSNP4L.mjs\";\nimport { CURRENT_DEV_INSTANCE_SUFFIXES, LEGACY_DEV_INSTANCE_SUFFIXES } from \"./chunk-I6MTSTOF.mjs\";\n\n// src/url.ts\nfunction parseSearchParams() {\n  let queryString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  if (queryString.startsWith(\"?\")) {\n    queryString = queryString.slice(1);\n  }\n  return new URLSearchParams(queryString);\n}\nfunction stripScheme() {\n  let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return (url || \"\").replace(/^.+:\\/\\//, \"\");\n}\nfunction addClerkPrefix(str) {\n  if (!str) {\n    return \"\";\n  }\n  let regex;\n  if (str.match(/^(clerk\\.)+\\w*$/)) {\n    regex = /(clerk\\.)*(?=clerk\\.)/;\n  } else if (str.match(/\\.clerk.accounts/)) {\n    return str;\n  } else {\n    regex = /^(clerk\\.)*/gi;\n  }\n  const stripped = str.replace(regex, \"\");\n  return `clerk.${stripped}`;\n}\nvar getClerkJsMajorVersionOrTag = (frontendApi, version) => {\n  if (!version && isStaging(frontendApi)) {\n    return \"canary\";\n  }\n  if (!version) {\n    return \"latest\";\n  }\n  return version.split(\".\")[0] || \"latest\";\n};\nvar getScriptUrl = (frontendApi, _ref) => {\n  let {\n    clerkJSVersion\n  } = _ref;\n  const noSchemeFrontendApi = frontendApi.replace(/http(s)?:\\/\\//, \"\");\n  const major = getClerkJsMajorVersionOrTag(frontendApi, clerkJSVersion);\n  return `https://${noSchemeFrontendApi}/npm/@clerk/clerk-js@${clerkJSVersion || major}/dist/clerk.browser.js`;\n};\nfunction isLegacyDevAccountPortalOrigin(host) {\n  return LEGACY_DEV_INSTANCE_SUFFIXES.some(legacyDevSuffix => {\n    return host.startsWith(\"accounts.\") && host.endsWith(legacyDevSuffix);\n  });\n}\nfunction isCurrentDevAccountPortalOrigin(host) {\n  return CURRENT_DEV_INSTANCE_SUFFIXES.some(currentDevSuffix => {\n    return host.endsWith(currentDevSuffix) && !host.endsWith(\".clerk\" + currentDevSuffix);\n  });\n}\nvar TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nfunction hasTrailingSlash() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  let respectQueryAndFragment = arguments.length > 1 ? arguments[1] : undefined;\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withTrailingSlash() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  let respectQueryAndFragment = arguments.length > 1 ? arguments[1] : undefined;\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withoutTrailingSlash() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  let respectQueryAndFragment = arguments.length > 1 ? arguments[1] : undefined;\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return input.split(\"://\").map(string_ => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nvar JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction joinURL(base) {\n  let url = base || \"\";\n  for (var _len = arguments.length, input = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    input[_key - 1] = arguments[_key];\n  }\n  for (const segment of input.filter(url2 => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nvar isAbsoluteUrl = url => ABSOLUTE_URL_REGEX.test(url);\nexport { parseSearchParams, stripScheme, addClerkPrefix, getClerkJsMajorVersionOrTag, getScriptUrl, isLegacyDevAccountPortalOrigin, isCurrentDevAccountPortalOrigin, hasTrailingSlash, withTrailingSlash, withoutTrailingSlash, hasLeadingSlash, withoutLeadingSlash, withLeadingSlash, cleanDoubleSlashes, isNonEmptyURL, joinURL, isAbsoluteUrl };\n//# sourceMappingURL=chunk-IFTVZ2LQ.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}